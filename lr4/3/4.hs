  {-
    4*. Напишите  функцию,  объединяющую  два заданных списка,  если
    сумма максимального элемента первого списка и минимального элемента
    второго списка  равна  заданному числу;  в противном случае функция
    возвращает пустой список.
  -}

  -- Определяет, равны ли значения аргументов, с точностью 10^-6
  eq :: (Ord a, Fractional a) => a -> a -> Bool
  eq a b = abs (a - b) <= 10 ^^ (-6)

  {-
    Склеивает два списка lst1 и lst2 по условию на с. 3-4
    в зависимости от заданного числового аргумента x;
    В противном случае возвращает пустой список.
    Вернет ошибку, если хотя бы один из списков пуст.
  -}
  concatBy :: (Ord a, Fractional a) => [a] -> [a] -> a -> [a]
  concatBy lst1 lst2 x | eq s x = lst1 ++ lst2
                       | True   = []
                        where s = maximum lst1 + minimum lst2

  -- Неудачные тестовые примеры:

  test1 = concatBy [0] [0] 0                              == [0, 0]
  test2 = concatBy [1, 2, 3] [3, 1] 4                     == [1, 2, 3, 3, 1]
  test3 = concatBy [1.0, 0.0] [1.0, 2.0] 2.0              == [1.0, 0.0, 1.0, 2.0]
  test4 = concatBy [1.00000001, 0.0] [1.0000004, 2.0] 2.0 == [1.00000001, 0.0, 1.0000004, 2.0]
  test5 = concatBy [-3.1, -8.4] [0.4, 3.8] (-2.7)         == [-3.1, -8.4, 0.4, 3.8]
  test6 = concatBy [1, 4] [5, 3] 20                       == []
  test7 = concatBy [-1.8, -3.0] [1.0, 8.0] (-0.7999999)   == [-1.8, -3.0, 1.0, 8.0]

  test = test1 && test2 && test3 && test4 && test5 && test6 && test7


